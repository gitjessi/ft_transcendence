Fastify, c’est un framework web pour Node.js (comme Express) conçu pour être ultra-rapide, simple à utiliser et bien typé avec TypeScript. 
Il sert à créer une API HTTP (routes GET/POST/PUT/DELETE), gérer les requêtes/réponses, 
valider les données d’entrée, brancher des plugins (CORS, WebSocket, Swagger, etc.), et logger proprement.

Qu'est ce que nodejs :
nodejs est le moteur qui execute du Javascript
il lit et execute le JS

Qui est TypeSript(tsc) :
C est le traducteur (TS->JS)

tsc = compilateur qui :
lit tsconfig.json (ex. target, module, strict…),
vérifie les types,
génère du JS (ex. dist/server.js).
Les types disparaissent à l’exécution : Node ne voit que du JS.

Qu'est ce le npm :
le gestionnaire de paquets (installe libs, lance scripts)
Sert à lancer des scripts :
npm run build → exécute la commande build déclarée.
npm start → exécute le script start.

CommonJS = ancien système de modules de Node (require).
ESM (ECMAScript Modules) = standard moderne (import/export) -> ajout Type: module dans package.json pour que ca fonctionne

--> Dans tes imports locaux, mettre l’extension .js si j'importes des fichiers 
(ex. import { x } from './utils.js'), même si la source est .ts --> pour que Node (en ESM) 
retrouve le bon fichier au moment d’exécuter le JavaScript compilé.

synchrone = deja en memoire -> lire juste une variable

Quand a-t-on besoin d’async? 
Dès que tu fais une opération I/O (Entrée/Sortie) qui prend du temps :

-> fichier / disque à lire à la volée : await readFile(...)
-> base de données : await prisma.player.findMany()
-> appel HTTP externe : await fetch(...)
-> import dynamique (au runtime) : const mod = await import('./x.js')

await permet ensuite d'attendre que l'instruction soit fini.


request
C’est l’objet requête (ce que le client envoie). lis :

-> params : parties dynamiques de l’URL (/players/:id)
-> query : paramètres après ? (/players?alias=jessi)
-> body : contenu JSON d’un POST/PUT
-> headers : en-têtes HTTP


reply
C’est l’objet réponse (ce que ton serveur renvoie). Tu t’en sers pour :

-> changer le statut HTTP : reply.code(201)
-> ajouter des en-têtes : reply.header('X-Info', 'ok')
-> envoyer la réponse : reply.send(data)